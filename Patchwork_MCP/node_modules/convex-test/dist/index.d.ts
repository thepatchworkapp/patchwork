import { DataModelFromSchemaDefinition, FunctionReference, FunctionReturnType, GenericActionCtx, GenericDataModel, GenericMutationCtx, GenericSchema, OptionalRestArgs, SchemaDefinition, UserIdentity } from "convex/server";
export type TestConvex<SchemaDef extends SchemaDefinition<any, boolean>> = TestConvexForDataModelAndIdentity<DataModelFromSchemaDefinition<SchemaDef>>;
export type TestConvexForDataModel<DataModel extends GenericDataModel> = {
    /**
     * Call a public or internal query.
     *
     * @param query A {@link FunctionReference} for the query.
     * @param args  An arguments object for the query. If this is omitted,
     *   the arguments will be `{}`.
     * @returns A `Promise` of the query's result.
     */
    query: <Query extends FunctionReference<"query", any>>(query: Query, ...args: OptionalRestArgs<Query>) => Promise<FunctionReturnType<Query>>;
    /**
     * Call a public or internal mutation.
     *
     * @param mutation A {@link FunctionReference} for the mutation.
     * @param args  An arguments object for the mutation. If this is omitted,
     *   the arguments will be `{}`.
     * @returns A `Promise` of the mutation's result.
     */
    mutation: <Mutation extends FunctionReference<"mutation", any>>(mutation: Mutation, ...args: OptionalRestArgs<Mutation>) => Promise<FunctionReturnType<Mutation>>;
    /**
     * Call a public or internal action.
     *
     * @param action A {@link FunctionReference} for the action.
     * @param args  An arguments object for the action. If this is omitted,
     *   the arguments will be `{}`.
     * @returns A `Promise` of the action's result.
     */
    action: <Action extends FunctionReference<"action", any>>(action: Action, ...args: OptionalRestArgs<Action>) => Promise<FunctionReturnType<Action>>;
    /**
     * Read from and write to the mock backend.
     *
     * @param func The async function that reads or writes to the mock backend.
     *   It receives a ctx as its first argument that conforms to
     *   {@link GenericMutationCtx},
     *   so it can be passed to functions that expect either context, use file
     *   storage, etc.
     * @returns A `Promise` of the function's result.
     */
    run: <Output>(func: (ctx: GenericMutationCtx<DataModel> & Pick<GenericActionCtx<DataModel>, "storage">) => Promise<Output>) => Promise<Output>;
    /**
     * Call an HTTP action.
     *
     * @param path The request URL's path and optional query and fragment.
     * @param init Standard `fetch` options.
     */
    fetch(pathQueryFragment: string, init?: RequestInit): Promise<Response>;
    /**
     * Wait for all scheduled functions currently in the "inProgress" state
     * to either finish successfully or fail.
     *
     * Use in combination with `vi.useFakeTimers()` and `vi.runAllTimers()`
     * to control precisely the execution of scheduled functions.
     *
     * Typically:
     * 1. Use `vi.runAllTimers()` or similar to advance
     *   time such that a function is scheduled.
     * 2. Use `finishInProgressScheduledFunctions()` to wait for the function
     */
    finishInProgressScheduledFunctions: () => Promise<void>;
    /**
     * Wait for all currently scheduled functions and any functions they
     * schedule to either finish successfully or fail.
     *
     * Use in combination with `vi.useFakeTimers()` to test scheduled functions.
     *
     * @param advanceTimers Function that advances timers,
     *   usually `vi.runAllTimers`. This function will be called in a loop
     *   with `finishInProgressScheduledFunctions()`.
     */
    finishAllScheduledFunctions: (advanceTimers: () => void) => Promise<void>;
};
export type TestConvexForDataModelAndIdentity<DataModel extends GenericDataModel> = {
    /**
     * To test functions which depend on the current authenticated user identity
     * you can create a version of the `t` accessor with given user identity
     * attributes.
     * @param identity A subset of {@link UserIdentity} attributes. If you
     *   don't provide `issuer`, `subject` or `tokenIdentifier` they are
     *   generated automatically.
     */
    withIdentity(identity: Partial<UserIdentity>): TestConvexForDataModel<DataModel>;
    registerComponent: (componentPath: string, schema: SchemaDefinition<GenericSchema, boolean>, glob: Record<string, () => Promise<any>>) => void;
} & TestConvexForDataModel<DataModel>;
/**
 * Call this function at the start of each of your tests.
 *
 * @param schema The default export from your "schema.ts" file.
 * @param modules If you have a custom `functions` path
 *   in convex.json, provide the module map with your functions
 *   by calling `import.meta.glob` with the appropriate glob pattern
 *   for paths relative to the file where you call it.
 * @returns an object which is by convention stored in the `t` variable
 *   and which provides methods for exercising your Convex functions.
 */
export declare const convexTest: <Schema extends GenericSchema>(schema?: SchemaDefinition<Schema, boolean>, modules?: Record<string, () => Promise<any>>) => TestConvex<SchemaDefinition<Schema, boolean>>;
//# sourceMappingURL=index.d.ts.map