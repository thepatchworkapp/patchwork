import { toKey as serialize } from "../lib/primitive.js";
import { encodeBound } from "../lib/tupleKey.js";
import { DatabaseRange } from "./databaseRange.js";
export class FilterKeyRange extends DatabaseRange {
    filterKey;
    filterValue;
    constructor(ctx, logger, filterKey, filterValue, cursor, interval, prefetchSize, stats) {
        super(ctx, logger, cursor, interval, prefetchSize, stats);
        this.filterKey = filterKey;
        this.filterValue = filterValue;
    }
    async initialQuery() {
        const docs = await this.ctx.db
            .query("pointsByFilterKey")
            .withIndex("filterKey", (q) => {
            const withFilter = q
                .eq("filterKey", this.filterKey)
                .eq("filterValue", this.filterValue);
            let withStart;
            if (this.cursor !== undefined) {
                withStart = withFilter.gt("tupleKey", this.cursor);
            }
            else if (this.interval.startInclusive !== undefined) {
                const bound = encodeBound(this.interval.startInclusive);
                withStart = withFilter.gte("tupleKey", bound);
            }
            else {
                withStart = withFilter;
            }
            let withEnd;
            if (this.interval.endExclusive !== undefined) {
                const bound = encodeBound(this.interval.endExclusive);
                withEnd = withStart.lt("tupleKey", bound);
            }
            else {
                withEnd = withStart;
            }
            return withEnd;
        })
            .take(this.prefetchSize);
        this.logger.debug(`Initial query for filter key ${this.filterKey} returned ${docs.length} results`);
        return docs.map((doc) => doc.tupleKey);
    }
    async advanceQuery(lastKey) {
        const docs = await this.ctx.db
            .query("pointsByFilterKey")
            .withIndex("filterKey", (q) => {
            const withStart = q
                .eq("filterKey", this.filterKey)
                .eq("filterValue", this.filterValue)
                .gt("tupleKey", lastKey);
            let withEnd;
            if (this.interval.endExclusive !== undefined) {
                const bound = encodeBound(this.interval.endExclusive);
                withEnd = withStart.lt("tupleKey", bound);
            }
            else {
                withEnd = withStart;
            }
            return withEnd;
        })
            .take(this.prefetchSize);
        this.logger.debug(`Advance query for filter key ${this.filterKey} returned ${docs.length} results`);
        return docs.map((doc) => doc.tupleKey);
    }
    async seekQuery(tuple) {
        const docs = await this.ctx.db
            .query("pointsByFilterKey")
            .withIndex("filterKey", (q) => {
            const withStart = q
                .eq("filterKey", this.filterKey)
                .eq("filterValue", this.filterValue)
                .gte("tupleKey", tuple);
            let withEnd;
            if (this.interval.endExclusive !== undefined) {
                const bound = encodeBound(this.interval.endExclusive);
                withEnd = withStart.lt("tupleKey", bound);
            }
            else {
                withEnd = withStart;
            }
            return withEnd;
        })
            .take(this.prefetchSize);
        this.logger.debug(`Seek query for filter key ${this.filterKey} returned ${docs.length} results`);
        return docs.map((doc) => doc.tupleKey);
    }
    getCounterKey() {
        return filterCounterKey(this.filterKey, this.filterValue);
    }
}
export function filterCounterKey(filterKey, filterValue) {
    return "filter:" + filterKey + ":" + serialize(filterValue);
}
//# sourceMappingURL=filterKeyRange.js.map