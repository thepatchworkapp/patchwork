import { encodeBound } from "../lib/tupleKey.js";
import { DatabaseRange } from "./databaseRange.js";
export class CellRange extends DatabaseRange {
    cell;
    constructor(ctx, logger, cell, cursor, interval, prefetchSize, stats) {
        super(ctx, logger, cursor, interval, prefetchSize, stats);
        this.cell = cell;
    }
    async initialQuery() {
        const docs = await this.ctx.db
            .query("pointsByCell")
            .withIndex("cell", (q) => {
            const withCell = q.eq("cell", this.cell);
            let withStart;
            if (this.cursor !== undefined) {
                withStart = withCell.gt("tupleKey", this.cursor);
            }
            else if (this.interval.startInclusive !== undefined) {
                const bound = encodeBound(this.interval.startInclusive);
                withStart = withCell.gte("tupleKey", bound);
            }
            else {
                withStart = withCell;
            }
            let withEnd;
            if (this.interval.endExclusive !== undefined) {
                const bound = encodeBound(this.interval.endExclusive);
                withEnd = withStart.lt("tupleKey", bound);
            }
            else {
                withEnd = withStart;
            }
            return withEnd;
        })
            .take(this.prefetchSize);
        this.logger.debug(`Initial query for cell ${this.cell} returned ${docs.length} results`, docs);
        return docs.map((doc) => doc.tupleKey);
    }
    async advanceQuery(lastKey) {
        const docs = await this.ctx.db
            .query("pointsByCell")
            .withIndex("cell", (q) => {
            const withStart = q.eq("cell", this.cell).gt("tupleKey", lastKey);
            let withEnd;
            if (this.interval.endExclusive !== undefined) {
                const bound = encodeBound(this.interval.endExclusive);
                withEnd = withStart.lt("tupleKey", bound);
            }
            else {
                withEnd = withStart;
            }
            return withEnd;
        })
            .take(this.prefetchSize);
        this.logger.debug(`Advance query for cell ${this.cell} returned ${docs.length} results`, docs);
        return docs.map((doc) => doc.tupleKey);
    }
    async seekQuery(tuple) {
        const docs = await this.ctx.db
            .query("pointsByCell")
            .withIndex("cell", (q) => {
            const withStart = q.eq("cell", this.cell).gte("tupleKey", tuple);
            let withEnd;
            if (this.interval.endExclusive !== undefined) {
                const bound = encodeBound(this.interval.endExclusive);
                withEnd = withStart.lt("tupleKey", bound);
            }
            else {
                withEnd = withStart;
            }
            return withEnd;
        })
            .take(this.prefetchSize);
        this.logger.debug(`Seek query for cell ${this.cell} returned ${docs.length} results`, docs);
        return docs.map((doc) => doc.tupleKey);
    }
    getCounterKey() {
        return cellCounterKey(this.cell);
    }
}
export function cellCounterKey(cell) {
    return "cell:" + cell;
}
//# sourceMappingURL=cellRange.js.map