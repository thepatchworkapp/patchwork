import { Heap } from "heap-js";
import type { ChordAngle, Meters, Point, Primitive } from "../types.js";
import type { Id } from "../_generated/dataModel.js";
import { S2Bindings } from "./s2Bindings.js";
import type { QueryCtx } from "../_generated/server.js";
import type { Logger } from "./logging.js";
import type { Interval } from "./interval.js";
type FilterCondition = {
    filterKey: string;
    filterValue: Primitive;
    occur: "must" | "should";
};
export declare class ClosestPointQuery {
    private s2;
    private logger;
    private point;
    private maxDistance;
    private maxResults;
    private minLevel;
    private maxLevel;
    private levelMod;
    toProcess: Heap<CellCandidate>;
    results: Heap<Result>;
    maxDistanceChordAngle?: ChordAngle;
    private mustFilters;
    private shouldFilters;
    private sortInterval;
    private readonly checkFilters;
    private static readonly FILTER_SUBDIVIDE_THRESHOLD;
    private cellStreams;
    constructor(s2: S2Bindings, logger: Logger, point: Point, maxDistance: Meters | undefined, maxResults: number, minLevel: number, maxLevel: number, levelMod: number, filtering?: FilterCondition[], interval?: Interval);
    execute(ctx: QueryCtx): Promise<{
        key: string;
        coordinates: {
            latitude: number;
            longitude: number;
        };
        distance: number;
    }[]>;
    private shouldStopProcessingCell;
    private withinSortInterval;
    private getOrCreateStreamForCell;
    private matchesFilters;
    private pointMatchesCondition;
    addCandidate(cellID: bigint, level: number, distance: ChordAngle): void;
    popCandidate(): CellCandidate | null;
    addResult(pointID: Id<"points">, point: Point): void;
    distanceThreshold(): ChordAngle | undefined;
}
type CellCandidate = {
    cellID: bigint;
    level: number;
    distance: ChordAngle;
};
type Result = {
    pointID: Id<"points">;
    distance: ChordAngle;
};
export {};
//# sourceMappingURL=pointQuery.d.ts.map