import {
  require_jsx_runtime
} from "./chunk-S725DACQ.js";
import {
  Authenticated,
  ConvexProviderWithAuth,
  useConvexAuth,
  useQuery
} from "./chunk-5ZKLRANZ.js";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import "./chunk-4OZKMT2L.js";
import {
  __publicField,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/@convex-dev/better-auth/dist/react/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
function ConvexBetterAuthProvider({ children, client, authClient, initialToken }) {
  const useBetterAuth = useUseAuthFromBetterAuth(authClient, initialToken);
  (0, import_react.useEffect)(() => {
    (async () => {
      var _a, _b;
      const url = new URL((_a = window.location) == null ? void 0 : _a.href);
      const token = url.searchParams.get("ott");
      if (token) {
        const authClientWithCrossDomain = authClient;
        url.searchParams.delete("ott");
        const result = await authClientWithCrossDomain.crossDomain.oneTimeToken.verify({
          token
        });
        const session = (_b = result.data) == null ? void 0 : _b.session;
        if (session) {
          await authClient.getSession({
            fetchOptions: {
              headers: {
                Authorization: `Bearer ${session.token}`
              }
            }
          });
          authClientWithCrossDomain.updateSession();
        }
        window.history.replaceState({}, "", url);
      }
    })();
  }, [authClient]);
  return (0, import_jsx_runtime.jsx)(ConvexProviderWithAuth, { client, useAuth: useBetterAuth, children: (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }) });
}
var initialTokenUsed = false;
function useUseAuthFromBetterAuth(authClient, initialToken) {
  const [cachedToken, setCachedToken] = (0, import_react.useState)(initialTokenUsed ? initialToken ?? null : null);
  (0, import_react.useEffect)(() => {
    if (!initialTokenUsed) {
      initialTokenUsed = true;
    }
  }, []);
  return (0, import_react.useMemo)(() => function useAuthFromBetterAuth() {
    var _a;
    const { data: session, isPending: isSessionPending } = authClient.useSession();
    const sessionId = (_a = session == null ? void 0 : session.session) == null ? void 0 : _a.id;
    (0, import_react.useEffect)(() => {
      if (!session && !isSessionPending && cachedToken) {
        setCachedToken(null);
      }
    }, [session, isSessionPending]);
    const fetchAccessToken = (0, import_react.useCallback)(
      async ({ forceRefreshToken = false } = {}) => {
        if (cachedToken && !forceRefreshToken) {
          return cachedToken;
        }
        try {
          const { data } = await authClient.convex.token();
          const token = (data == null ? void 0 : data.token) || null;
          setCachedToken(token);
          return token;
        } catch {
          setCachedToken(null);
          return null;
        }
      },
      // Build a new fetchAccessToken to trigger setAuth() whenever the
      // session changes.
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [sessionId]
    );
    return (0, import_react.useMemo)(
      () => ({
        isLoading: isSessionPending,
        isAuthenticated: session !== null,
        fetchAccessToken
      }),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [isSessionPending, sessionId, fetchAccessToken]
    );
  }, [authClient]);
}
var ErrorBoundary = class extends import_react.Component {
  constructor(props) {
    super(props);
    this.state = {};
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  async componentDidCatch(error) {
    if (this.props.isAuthError(error)) {
      await this.props.onUnauth();
    }
  }
  render() {
    var _a, _b;
    if (this.state.error && this.props.isAuthError(this.state.error)) {
      return (_b = (_a = this.props).renderFallback) == null ? void 0 : _b.call(_a);
    }
    return this.props.children;
  }
};
__publicField(ErrorBoundary, "defaultProps", {
  renderFallback: () => null
});
var UserSubscription = ({ getAuthUserFn }) => {
  useQuery(getAuthUserFn);
  return null;
};
var AuthBoundary = ({
  children,
  /**
   * The function to call when the user is unauthenticated. Typically a redirect
   * to the login page.
   */
  onUnauth,
  /**
   * The Better Auth authClient to use.
   */
  authClient,
  /**
   * The fallback to render when the user is unauthenticated. Defaults to null.
   * Generally not rendered as error handling is typically a redirect.
   */
  renderFallback,
  /**
   * The function to call to get the auth user.
   */
  getAuthUserFn,
  /**
   * The function to call to check if the error is auth related.
   */
  isAuthError
}) => {
  const { isAuthenticated, isLoading } = useConvexAuth();
  const handleUnauth = (0, import_react.useCallback)(async () => {
    await authClient.getSession();
    await onUnauth();
  }, [onUnauth]);
  (0, import_react.useEffect)(() => {
    void (async () => {
      if (!isLoading && !isAuthenticated) {
        await handleUnauth();
      }
    })();
  }, [isLoading, isAuthenticated]);
  return (0, import_jsx_runtime.jsxs)(ErrorBoundary, { onUnauth: handleUnauth, isAuthError, renderFallback, children: [(0, import_jsx_runtime.jsx)(Authenticated, { children: (0, import_jsx_runtime.jsx)(UserSubscription, { getAuthUserFn }) }), children] });
};
export {
  AuthBoundary,
  ConvexBetterAuthProvider
};
//# sourceMappingURL=@convex-dev_better-auth_react.js.map
