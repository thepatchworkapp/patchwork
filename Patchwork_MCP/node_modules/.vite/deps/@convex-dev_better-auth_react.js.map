{
  "version": 3,
  "sources": ["../../@convex-dev/better-auth/src/react/index.tsx"],
  "sourcesContent": ["import type { PropsWithChildren, ReactNode } from \"react\";\nimport { Component, useCallback, useEffect, useMemo, useState } from \"react\";\nimport type { AuthTokenFetcher } from \"convex/browser\";\nimport {\n  Authenticated,\n  ConvexProviderWithAuth,\n  useConvexAuth,\n  useQuery,\n} from \"convex/react\";\nimport type { FunctionReference } from \"convex/server\";\nimport type { BetterAuthClientPlugin } from \"better-auth\";\nimport type { createAuthClient } from \"better-auth/react\";\nimport type {\n  convexClient,\n  crossDomainClient,\n} from \"../client/plugins/index.js\";\nimport type { EmptyObject } from \"convex-helpers\";\n\ntype CrossDomainClient = ReturnType<typeof crossDomainClient>;\ntype ConvexClient = ReturnType<typeof convexClient>;\ntype PluginsWithCrossDomain = (\n  | CrossDomainClient\n  | ConvexClient\n  | BetterAuthClientPlugin\n)[];\ntype PluginsWithoutCrossDomain = (ConvexClient | BetterAuthClientPlugin)[];\ntype AuthClientWithPlugins<\n  Plugins extends PluginsWithCrossDomain | PluginsWithoutCrossDomain,\n> = ReturnType<\n  typeof createAuthClient<\n    BetterAuthClientPlugin & {\n      plugins: Plugins;\n    }\n  >\n>;\nexport type AuthClient =\n  | AuthClientWithPlugins<PluginsWithCrossDomain>\n  | AuthClientWithPlugins<PluginsWithoutCrossDomain>;\n\n// Until we can import from our own entry points (requires TypeScript 4.7),\n// just describe the interface enough to help users pass the right type.\ntype IConvexReactClient = {\n  setAuth(fetchToken: AuthTokenFetcher): void;\n  clearAuth(): void;\n};\n\n/**\n * A wrapper React component which provides a {@link react.ConvexReactClient}\n * authenticated with Better Auth.\n *\n * @public\n */\nexport function ConvexBetterAuthProvider({\n  children,\n  client,\n  authClient,\n  initialToken,\n}: {\n  children: ReactNode;\n  client: IConvexReactClient;\n  authClient: AuthClient;\n  initialToken?: string | null;\n}) {\n  const useBetterAuth = useUseAuthFromBetterAuth(authClient, initialToken);\n  useEffect(() => {\n    (async () => {\n      const url = new URL(window.location?.href);\n      const token = url.searchParams.get(\"ott\");\n      if (token) {\n        const authClientWithCrossDomain =\n          authClient as AuthClientWithPlugins<PluginsWithCrossDomain>;\n        url.searchParams.delete(\"ott\");\n        const result =\n          await authClientWithCrossDomain.crossDomain.oneTimeToken.verify({\n            token,\n          });\n        const session = result.data?.session;\n        if (session) {\n          await authClient.getSession({\n            fetchOptions: {\n              headers: {\n                Authorization: `Bearer ${session.token}`,\n              },\n            },\n          });\n          authClientWithCrossDomain.updateSession();\n        }\n        window.history.replaceState({}, \"\", url);\n      }\n    })();\n  }, [authClient]);\n  return (\n    <ConvexProviderWithAuth client={client} useAuth={useBetterAuth}>\n      <>{children}</>\n    </ConvexProviderWithAuth>\n  );\n}\n\nlet initialTokenUsed = false;\n\nfunction useUseAuthFromBetterAuth(\n  authClient: AuthClient,\n  initialToken?: string | null\n) {\n  const [cachedToken, setCachedToken] = useState<string | null>(\n    initialTokenUsed ? (initialToken ?? null) : null\n  );\n  useEffect(() => {\n    if (!initialTokenUsed) {\n      initialTokenUsed = true;\n    }\n  }, []);\n\n  return useMemo(\n    () =>\n      function useAuthFromBetterAuth() {\n        const { data: session, isPending: isSessionPending } =\n          authClient.useSession();\n        const sessionId = session?.session?.id;\n        useEffect(() => {\n          if (!session && !isSessionPending && cachedToken) {\n            setCachedToken(null);\n          }\n        }, [session, isSessionPending]);\n        const fetchAccessToken = useCallback(\n          async ({\n            forceRefreshToken = false,\n          }: { forceRefreshToken?: boolean } = {}) => {\n            if (cachedToken && !forceRefreshToken) {\n              return cachedToken;\n            }\n            try {\n              const { data } = await authClient.convex.token();\n              const token = data?.token || null;\n              setCachedToken(token);\n              return token;\n            } catch {\n              setCachedToken(null);\n              return null;\n            }\n          },\n          // Build a new fetchAccessToken to trigger setAuth() whenever the\n          // session changes.\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          [sessionId]\n        );\n        return useMemo(\n          () => ({\n            isLoading: isSessionPending,\n            isAuthenticated: session !== null,\n            fetchAccessToken,\n          }),\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          [isSessionPending, sessionId, fetchAccessToken]\n        );\n      },\n    [authClient]\n  );\n}\n\ninterface ErrorBoundaryProps {\n  children: React.ReactNode;\n  onUnauth: () => void | Promise<void>;\n  renderFallback?: () => React.ReactNode;\n  isAuthError: (error: unknown) => boolean;\n}\ninterface ErrorBoundaryState {\n  error?: unknown;\n}\n\nclass ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = {};\n  }\n  static defaultProps: Partial<ErrorBoundaryProps> = {\n    renderFallback: () => null,\n  };\n  static getDerivedStateFromError(error: Error) {\n    return { error };\n  }\n  async componentDidCatch(error: Error) {\n    if (this.props.isAuthError(error)) {\n      await this.props.onUnauth();\n    }\n  }\n  render() {\n    if (this.state.error && this.props.isAuthError(this.state.error)) {\n      return this.props.renderFallback?.();\n    }\n    return this.props.children;\n  }\n}\n\n// Subscribe to the session validated user to keep this check reactive to\n// actual user auth state at the provider level (rather than just jwt validity state).\nconst UserSubscription = ({\n  getAuthUserFn,\n}: {\n  getAuthUserFn: FunctionReference<\"query\">;\n}) => {\n  useQuery(getAuthUserFn);\n  return null;\n};\n\n/**\n * _Experimental_\n *\n * A wrapper React component which provides error handling for auth related errors.\n * This is typically used to redirect the user to the login page when they are\n * unauthenticated, and does so reactively based on the getAuthUserFn query.\n *\n * @example\n * ```ts\n * // convex/auth.ts\n * export const { getAuthUser } = authComponent.clientApi();\n *\n * // auth-client.tsx\n * import { AuthBoundary } from \"@convex-dev/react\";\n * import { api } from '../../convex/_generated/api'\n * import { isAuthError } from '../lib/utils'\n *\n * export const ClientAuthBoundary = ({ children }: PropsWithChildren) => {\n *   return (\n *     <AuthBoundary\n *       onUnauth={() => redirect(\"/sign-in\")}\n *       authClient={authClient}\n *       getAuthUserFn={api.auth.getAuthUser}\n *       isAuthError={isAuthError}\n * >\n *   <>{children}</>\n * </AuthBoundary>\n * )\n * ```\n * @param props.children - Children to render.\n * @param props.onUnauth - Function to call when the user is\n * unauthenticated. Typically a redirect to the login page.\n * @param props.authClient - Better Auth authClient to use.\n * @param props.renderFallback - Fallback component to render when the user is\n * unauthenticated. Defaults to null. Generally not rendered as error handling\n * is typically a redirect.\n * @param props.getAuthUserFn - Reference to a Convex query that returns user.\n * The component provides a query for this via `export const { getAuthUser } = authComponent.clientApi()`.\n * @param props.isAuthError - Function to check if the error is auth related.\n */\nexport const AuthBoundary = ({\n  children,\n  /**\n   * The function to call when the user is unauthenticated. Typically a redirect\n   * to the login page.\n   */\n  onUnauth,\n  /**\n   * The Better Auth authClient to use.\n   */\n  authClient,\n  /**\n   * The fallback to render when the user is unauthenticated. Defaults to null.\n   * Generally not rendered as error handling is typically a redirect.\n   */\n  renderFallback,\n  /**\n   * The function to call to get the auth user.\n   */\n  getAuthUserFn,\n  /**\n   * The function to call to check if the error is auth related.\n   */\n  isAuthError,\n}: PropsWithChildren<{\n  onUnauth: () => void | Promise<void>;\n  authClient: AuthClient;\n  renderFallback?: () => React.ReactNode;\n  getAuthUserFn: FunctionReference<\"query\", \"public\", EmptyObject>;\n  isAuthError: (error: unknown) => boolean;\n}>) => {\n  const { isAuthenticated, isLoading } = useConvexAuth();\n  const handleUnauth = useCallback(async () => {\n    // Auth request that will clear cookies if session is invalid\n    await authClient.getSession();\n    await onUnauth();\n  }, [onUnauth]);\n\n  useEffect(() => {\n    void (async () => {\n      if (!isLoading && !isAuthenticated) {\n        await handleUnauth();\n      }\n    })();\n  }, [isLoading, isAuthenticated]);\n\n  return (\n    <ErrorBoundary\n      onUnauth={handleUnauth}\n      isAuthError={isAuthError}\n      renderFallback={renderFallback}\n    >\n      <Authenticated>\n        <UserSubscription getAuthUserFn={getAuthUserFn} />\n      </Authenticated>\n      {children}\n    </ErrorBoundary>\n  );\n};\n"],
  "mappings": "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",
  "names": ["_jsx", "_Fragment", "_jsxs"]
}
