import {
  BetterAuthError,
  atom,
  useAuthQuery
} from "./chunk-YPIZHD6O.js";
import "./chunk-DC5AMYBS.js";

// node_modules/better-auth/dist/plugins/additional-fields/client.mjs
var inferAdditionalFields = (schema) => {
  return {
    id: "additional-fields-client",
    $InferServerPlugin: {}
  };
};

// node_modules/better-auth/dist/plugins/access/access.mjs
function role(statements) {
  return {
    authorize(request, connector = "AND") {
      let success = false;
      for (const [requestedResource, requestedActions] of Object.entries(request)) {
        const allowedActions = statements[requestedResource];
        if (!allowedActions) return {
          success: false,
          error: `You are not allowed to access resource: ${requestedResource}`
        };
        if (Array.isArray(requestedActions)) success = requestedActions.every((requestedAction) => allowedActions.includes(requestedAction));
        else if (typeof requestedActions === "object") {
          const actions = requestedActions;
          if (actions.connector === "OR") success = actions.actions.some((requestedAction) => allowedActions.includes(requestedAction));
          else success = actions.actions.every((requestedAction) => allowedActions.includes(requestedAction));
        } else throw new BetterAuthError("Invalid access control request");
        if (success && connector === "OR") return { success };
        if (!success && connector === "AND") return {
          success: false,
          error: `unauthorized to access resource "${requestedResource}"`
        };
      }
      if (success) return { success };
      return {
        success: false,
        error: "Not authorized"
      };
    },
    statements
  };
}
function createAccessControl(s) {
  return {
    newRole(statements) {
      return role(statements);
    },
    statements: s
  };
}

// node_modules/better-auth/dist/plugins/admin/access/statement.mjs
var defaultStatements = {
  user: [
    "create",
    "list",
    "set-role",
    "ban",
    "impersonate",
    "delete",
    "set-password",
    "get",
    "update"
  ],
  session: [
    "list",
    "revoke",
    "delete"
  ]
};
var defaultAc = createAccessControl(defaultStatements);
var adminAc = defaultAc.newRole({
  user: [
    "create",
    "list",
    "set-role",
    "ban",
    "impersonate",
    "delete",
    "set-password",
    "get",
    "update"
  ],
  session: [
    "list",
    "revoke",
    "delete"
  ]
});
var userAc = defaultAc.newRole({
  user: [],
  session: []
});
var defaultRoles = {
  admin: adminAc,
  user: userAc
};

// node_modules/better-auth/dist/plugins/admin/has-permission.mjs
var hasPermission = (input) => {
  var _a, _b, _c, _d, _e, _f;
  if (input.userId && ((_b = (_a = input.options) == null ? void 0 : _a.adminUserIds) == null ? void 0 : _b.includes(input.userId))) return true;
  if (!input.permissions && !input.permission) return false;
  const roles = (input.role || ((_c = input.options) == null ? void 0 : _c.defaultRole) || "user").split(",");
  const acRoles = ((_d = input.options) == null ? void 0 : _d.roles) || defaultRoles;
  for (const role2 of roles) if ((_f = (_e = acRoles[role2]) == null ? void 0 : _e.authorize(input.permission ?? input.permissions)) == null ? void 0 : _f.success) return true;
  return false;
};

// node_modules/better-auth/dist/plugins/admin/client.mjs
var adminClient = (options) => {
  const roles = {
    admin: adminAc,
    user: userAc,
    ...options == null ? void 0 : options.roles
  };
  return {
    id: "admin-client",
    $InferServerPlugin: {},
    getActions: () => ({ admin: { checkRolePermission: (data) => {
      return hasPermission({
        role: data.role,
        options: {
          ac: options == null ? void 0 : options.ac,
          roles
        },
        permissions: data.permissions ?? data.permission
      });
    } } }),
    pathMethods: {
      "/admin/list-users": "GET",
      "/admin/stop-impersonating": "POST"
    }
  };
};

// node_modules/better-auth/dist/plugins/anonymous/client.mjs
var anonymousClient = () => {
  return {
    id: "anonymous",
    $InferServerPlugin: {},
    pathMethods: { "/sign-in/anonymous": "POST" },
    atomListeners: [{
      matcher: (path) => path === "/sign-in/anonymous",
      signal: "$sessionSignal"
    }]
  };
};

// node_modules/better-auth/dist/plugins/api-key/client.mjs
var apiKeyClient = () => {
  return {
    id: "api-key",
    $InferServerPlugin: {},
    pathMethods: {
      "/api-key/create": "POST",
      "/api-key/delete": "POST",
      "/api-key/delete-all-expired-api-keys": "POST"
    }
  };
};

// node_modules/better-auth/dist/client/plugins/infer-plugin.mjs
var InferServerPlugin = () => {
  return {
    id: "infer-server-plugin",
    $InferServerPlugin: {}
  };
};

// node_modules/better-auth/dist/plugins/custom-session/client.mjs
var customSessionClient = () => {
  return InferServerPlugin();
};

// node_modules/better-auth/dist/plugins/device-authorization/client.mjs
var deviceAuthorizationClient = () => {
  return {
    id: "device-authorization",
    $InferServerPlugin: {},
    pathMethods: {
      "/device/code": "POST",
      "/device/token": "POST",
      "/device": "GET",
      "/device/approve": "POST",
      "/device/deny": "POST"
    }
  };
};

// node_modules/better-auth/dist/plugins/email-otp/client.mjs
var emailOTPClient = () => {
  return {
    id: "email-otp",
    $InferServerPlugin: {},
    atomListeners: [{
      matcher: (path) => path === "/email-otp/verify-email" || path === "/sign-in/email-otp",
      signal: "$sessionSignal"
    }]
  };
};

// node_modules/better-auth/dist/plugins/generic-oauth/client.mjs
var genericOAuthClient = () => {
  return {
    id: "generic-oauth-client",
    $InferServerPlugin: {}
  };
};

// node_modules/better-auth/dist/plugins/jwt/client.mjs
var jwtClient = (options) => {
  var _a;
  const jwksPath = ((_a = options == null ? void 0 : options.jwks) == null ? void 0 : _a.jwksPath) ?? "/jwks";
  return {
    id: "better-auth-client",
    $InferServerPlugin: {},
    pathMethods: { [jwksPath]: "GET" },
    getActions: ($fetch) => ({ jwks: async (fetchOptions) => {
      return await $fetch(jwksPath, {
        method: "GET",
        ...fetchOptions
      });
    } })
  };
};

// node_modules/better-auth/dist/plugins/last-login-method/client.mjs
function getCookieValue(name) {
  if (typeof document === "undefined") return null;
  const cookie = document.cookie.split("; ").find((row) => row.startsWith(`${name}=`));
  return cookie ? cookie.split("=")[1] : null;
}
var lastLoginMethodClient = (config = {}) => {
  const cookieName = config.cookieName || "better-auth.last_used_login_method";
  return {
    id: "last-login-method-client",
    getActions() {
      return {
        getLastUsedLoginMethod: () => {
          return getCookieValue(cookieName);
        },
        clearLastUsedLoginMethod: () => {
          if (typeof document !== "undefined") document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
        },
        isLastUsedLoginMethod: (method) => {
          return getCookieValue(cookieName) === method;
        }
      };
    }
  };
};

// node_modules/better-auth/dist/plugins/magic-link/client.mjs
var magicLinkClient = () => {
  return {
    id: "magic-link",
    $InferServerPlugin: {}
  };
};

// node_modules/better-auth/dist/plugins/multi-session/client.mjs
var multiSessionClient = (options) => {
  return {
    id: "multi-session",
    $InferServerPlugin: {},
    atomListeners: [{
      matcher(path) {
        return path === "/multi-session/set-active";
      },
      signal: "$sessionSignal"
    }]
  };
};

// node_modules/better-auth/dist/plugins/oidc-provider/client.mjs
var oidcClient = () => {
  return {
    id: "oidc-client",
    $InferServerPlugin: {}
  };
};

// node_modules/better-auth/dist/plugins/one-tap/client.mjs
var isRequestInProgress = null;
function isFedCMSupported() {
  return typeof window !== "undefined" && "IdentityCredential" in window;
}
var oneTapClient = (options) => {
  return {
    id: "one-tap",
    fetchPlugins: [{
      id: "fedcm-signout-handle",
      name: "FedCM Sign-Out Handler",
      hooks: { async onResponse(ctx) {
        var _a;
        if (!ctx.request.url.toString().includes("/sign-out")) return;
        if (((_a = options.promptOptions) == null ? void 0 : _a.fedCM) === false || !isFedCMSupported()) return;
        navigator.credentials.preventSilentAccess();
      } }
    }],
    getActions: ($fetch, _) => {
      return { oneTap: async (opts, fetchOptions) => {
        var _a;
        if (isRequestInProgress && !isRequestInProgress.signal.aborted) {
          console.warn("A Google One Tap request is already in progress. Please wait.");
          return;
        }
        if (typeof window === "undefined" || !window.document) {
          console.warn("Google One Tap is only available in browser environments");
          return;
        }
        async function callback(idToken) {
          await $fetch("/one-tap/callback", {
            method: "POST",
            body: { idToken },
            ...opts == null ? void 0 : opts.fetchOptions,
            ...fetchOptions
          });
          if (!(opts == null ? void 0 : opts.fetchOptions) && !fetchOptions || (opts == null ? void 0 : opts.callbackURL)) window.location.href = (opts == null ? void 0 : opts.callbackURL) ?? "/";
        }
        const { autoSelect, cancelOnTapOutside, context } = opts ?? {};
        const contextValue = context ?? options.context ?? "signin";
        const clients = {
          fedCM: async () => {
            var _a2, _b;
            try {
              const identityCredential = await navigator.credentials.get({
                identity: {
                  context: contextValue,
                  providers: [{
                    configURL: "https://accounts.google.com/gsi/fedcm.json",
                    clientId: options.clientId,
                    nonce: opts == null ? void 0 : opts.nonce
                  }]
                },
                mediation: autoSelect ? "optional" : "required",
                signal: isRequestInProgress == null ? void 0 : isRequestInProgress.signal
              });
              if (!(identityCredential == null ? void 0 : identityCredential.token)) {
                (_a2 = opts == null ? void 0 : opts.onPromptNotification) == null ? void 0 : _a2.call(opts, void 0);
                return;
              }
              try {
                await callback(identityCredential.token);
                return;
              } catch (error) {
                console.error("Error during FedCM callback:", error);
                throw error;
              }
            } catch (error) {
              if ((error == null ? void 0 : error.code) && (error.code === 19 || error.code === 20)) {
                (_b = opts == null ? void 0 : opts.onPromptNotification) == null ? void 0 : _b.call(opts, void 0);
                return;
              }
              throw error;
            }
          },
          oneTap: () => {
            return new Promise((resolve, reject) => {
              var _a2, _b, _c;
              let isResolved = false;
              const baseDelay = ((_a2 = options.promptOptions) == null ? void 0 : _a2.baseDelay) ?? 1e3;
              const maxAttempts = ((_b = options.promptOptions) == null ? void 0 : _b.maxAttempts) ?? 5;
              (_c = window.google) == null ? void 0 : _c.accounts.id.initialize({
                client_id: options.clientId,
                callback: async (response) => {
                  isResolved = true;
                  try {
                    await callback(response.credential);
                    resolve();
                  } catch (error) {
                    console.error("Error during One Tap callback:", error);
                    reject(error);
                  }
                },
                auto_select: autoSelect,
                cancel_on_tap_outside: cancelOnTapOutside,
                context: contextValue,
                ux_mode: (opts == null ? void 0 : opts.uxMode) || "popup",
                nonce: opts == null ? void 0 : opts.nonce,
                itp_support: true,
                ...options.additionalOptions
              });
              const handlePrompt = (attempt) => {
                var _a3;
                if (isResolved) return;
                (_a3 = window.google) == null ? void 0 : _a3.accounts.id.prompt((notification) => {
                  var _a4, _b2;
                  if (isResolved) return;
                  if (notification.isDismissedMoment && notification.isDismissedMoment()) if (attempt < maxAttempts) {
                    const delay = Math.pow(2, attempt) * baseDelay;
                    setTimeout(() => handlePrompt(attempt + 1), delay);
                  } else (_a4 = opts == null ? void 0 : opts.onPromptNotification) == null ? void 0 : _a4.call(opts, notification);
                  else if (notification.isSkippedMoment && notification.isSkippedMoment()) if (attempt < maxAttempts) {
                    const delay = Math.pow(2, attempt) * baseDelay;
                    setTimeout(() => handlePrompt(attempt + 1), delay);
                  } else (_b2 = opts == null ? void 0 : opts.onPromptNotification) == null ? void 0 : _b2.call(opts, notification);
                });
              };
              handlePrompt(0);
            });
          }
        };
        if (isRequestInProgress) isRequestInProgress == null ? void 0 : isRequestInProgress.abort();
        isRequestInProgress = new AbortController();
        try {
          const client = ((_a = options.promptOptions) == null ? void 0 : _a.fedCM) === false || !isFedCMSupported() ? "oneTap" : "fedCM";
          if (client === "oneTap") await loadGoogleScript();
          await clients[client]();
        } catch (error) {
          console.error("Error during Google One Tap flow:", error);
          throw error;
        } finally {
          isRequestInProgress = null;
        }
      } };
    },
    getAtoms($fetch) {
      return {};
    }
  };
};
var loadGoogleScript = () => {
  return new Promise((resolve) => {
    if (window.googleScriptInitialized) {
      resolve();
      return;
    }
    const script = document.createElement("script");
    script.src = "https://accounts.google.com/gsi/client";
    script.async = true;
    script.defer = true;
    script.onload = () => {
      window.googleScriptInitialized = true;
      resolve();
    };
    document.head.appendChild(script);
  });
};

// node_modules/better-auth/dist/plugins/one-time-token/client.mjs
var oneTimeTokenClient = () => {
  return {
    id: "one-time-token",
    $InferServerPlugin: {}
  };
};

// node_modules/better-auth/dist/plugins/organization/access/statement.mjs
var defaultStatements2 = {
  organization: ["update", "delete"],
  member: [
    "create",
    "update",
    "delete"
  ],
  invitation: ["create", "cancel"],
  team: [
    "create",
    "update",
    "delete"
  ],
  ac: [
    "create",
    "read",
    "update",
    "delete"
  ]
};
var defaultAc2 = createAccessControl(defaultStatements2);
var adminAc2 = defaultAc2.newRole({
  organization: ["update"],
  invitation: ["create", "cancel"],
  member: [
    "create",
    "update",
    "delete"
  ],
  team: [
    "create",
    "update",
    "delete"
  ],
  ac: [
    "create",
    "read",
    "update",
    "delete"
  ]
});
var ownerAc = defaultAc2.newRole({
  organization: ["update", "delete"],
  member: [
    "create",
    "update",
    "delete"
  ],
  invitation: ["create", "cancel"],
  team: [
    "create",
    "update",
    "delete"
  ],
  ac: [
    "create",
    "read",
    "update",
    "delete"
  ]
});
var memberAc = defaultAc2.newRole({
  organization: [],
  member: [],
  invitation: [],
  team: [],
  ac: ["read"]
});
var defaultRoles2 = {
  admin: adminAc2,
  owner: ownerAc,
  member: memberAc
};

// node_modules/better-auth/dist/plugins/organization/permission.mjs
var hasPermissionFn = (input, acRoles) => {
  var _a, _b;
  if (!input.permissions && !input.permission) return false;
  const roles = input.role.split(",");
  const creatorRole = input.options.creatorRole || "owner";
  const isCreator = roles.includes(creatorRole);
  const allowCreatorsAllPermissions = input.allowCreatorAllPermissions || false;
  if (isCreator && allowCreatorsAllPermissions) return true;
  for (const role2 of roles) if ((_b = (_a = acRoles[role2]) == null ? void 0 : _a.authorize(input.permissions ?? input.permission)) == null ? void 0 : _b.success) return true;
  return false;
};

// node_modules/better-auth/dist/plugins/organization/client.mjs
var clientSideHasPermission = (input) => {
  return hasPermissionFn(input, input.options.roles || defaultRoles2);
};
var organizationClient = (options) => {
  const $listOrg = atom(false);
  const $activeOrgSignal = atom(false);
  const $activeMemberSignal = atom(false);
  const $activeMemberRoleSignal = atom(false);
  const roles = {
    admin: adminAc2,
    member: memberAc,
    owner: ownerAc,
    ...options == null ? void 0 : options.roles
  };
  return {
    id: "organization",
    $InferServerPlugin: {},
    getActions: ($fetch, _$store, co) => ({
      $Infer: {
        ActiveOrganization: {},
        Organization: {},
        Invitation: {},
        Member: {},
        Team: {}
      },
      organization: { checkRolePermission: (data) => {
        return clientSideHasPermission({
          role: data.role,
          options: {
            ac: options == null ? void 0 : options.ac,
            roles
          },
          permissions: data.permissions ?? data.permission
        });
      } }
    }),
    getAtoms: ($fetch) => {
      const listOrganizations = useAuthQuery($listOrg, "/organization/list", $fetch, { method: "GET" });
      return {
        $listOrg,
        $activeOrgSignal,
        $activeMemberSignal,
        $activeMemberRoleSignal,
        activeOrganization: useAuthQuery([$activeOrgSignal], "/organization/get-full-organization", $fetch, () => ({ method: "GET" })),
        listOrganizations,
        activeMember: useAuthQuery([$activeMemberSignal], "/organization/get-active-member", $fetch, { method: "GET" }),
        activeMemberRole: useAuthQuery([$activeMemberRoleSignal], "/organization/get-active-member-role", $fetch, { method: "GET" })
      };
    },
    pathMethods: {
      "/organization/get-full-organization": "GET",
      "/organization/list-user-teams": "GET"
    },
    atomListeners: [
      {
        matcher(path) {
          return path === "/organization/create" || path === "/organization/delete" || path === "/organization/update";
        },
        signal: "$listOrg"
      },
      {
        matcher(path) {
          return path.startsWith("/organization");
        },
        signal: "$activeOrgSignal"
      },
      {
        matcher(path) {
          return path.startsWith("/organization/set-active");
        },
        signal: "$sessionSignal"
      },
      {
        matcher(path) {
          return path.includes("/organization/update-member-role");
        },
        signal: "$activeMemberSignal"
      },
      {
        matcher(path) {
          return path.includes("/organization/update-member-role");
        },
        signal: "$activeMemberRoleSignal"
      }
    ]
  };
};
var inferOrgAdditionalFields = (schema) => {
  return {};
};

// node_modules/better-auth/dist/plugins/phone-number/client.mjs
var phoneNumberClient = () => {
  return {
    id: "phoneNumber",
    $InferServerPlugin: {},
    atomListeners: [{
      matcher(path) {
        return path === "/phone-number/update" || path === "/phone-number/verify" || path === "/sign-in/phone-number";
      },
      signal: "$sessionSignal"
    }]
  };
};

// node_modules/better-auth/dist/plugins/siwe/client.mjs
var siweClient = () => {
  return {
    id: "siwe",
    $InferServerPlugin: {}
  };
};

// node_modules/better-auth/dist/plugins/two-factor/client.mjs
var twoFactorClient = (options) => {
  return {
    id: "two-factor",
    $InferServerPlugin: {},
    atomListeners: [{
      matcher: (path) => path.startsWith("/two-factor/"),
      signal: "$sessionSignal"
    }],
    pathMethods: {
      "/two-factor/disable": "POST",
      "/two-factor/enable": "POST",
      "/two-factor/send-otp": "POST",
      "/two-factor/generate-backup-codes": "POST"
    },
    fetchPlugins: [{
      id: "two-factor",
      name: "two-factor",
      hooks: { async onSuccess(context) {
        var _a;
        if ((_a = context.data) == null ? void 0 : _a.twoFactorRedirect) {
          if (options == null ? void 0 : options.onTwoFactorRedirect) await options.onTwoFactorRedirect();
        }
      } }
    }]
  };
};

// node_modules/better-auth/dist/plugins/username/client.mjs
var usernameClient = () => {
  return {
    id: "username",
    $InferServerPlugin: {},
    atomListeners: [{
      matcher: (path) => path === "/sign-in/username",
      signal: "$sessionSignal"
    }]
  };
};
export {
  InferServerPlugin,
  adminClient,
  anonymousClient,
  apiKeyClient,
  clientSideHasPermission,
  customSessionClient,
  deviceAuthorizationClient,
  emailOTPClient,
  genericOAuthClient,
  inferAdditionalFields,
  inferOrgAdditionalFields,
  jwtClient,
  lastLoginMethodClient,
  magicLinkClient,
  multiSessionClient,
  oidcClient,
  oneTapClient,
  oneTimeTokenClient,
  organizationClient,
  phoneNumberClient,
  siweClient,
  twoFactorClient,
  usernameClient
};
//# sourceMappingURL=better-auth_client_plugins.js.map
